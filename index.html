<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<title>Learn Lambda Prolog!</title>
		<link href="styles/style.css" rel="stylesheet" type="text/css">

		<script type="text/javascript" src="jquery.js"></script>

		<link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet">

		<!--
		Fonts:
			Title: Playfair Display
			Headings: Open Sans Bold
			Emphasized points, bullets: Slabo 27px
			Open Sans Condensed Light
			Lobster Two
		-->

		<!-- Remove unused fonts; Open+Sans:400,700|Open+Sans+Condensed:300|Playfair+Display|-->

		<link href="https://fonts.googleapis.com/css?family=Roboto|Slabo+27px|Lobster+Two" rel="stylesheet">

		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				tex2jax: { inlineMath : [['$','$'], ['\\(','\\)']] },
				"HTML-CSS" : { preferredFont : "STIX" }
			});
		</script>

		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


		<script type="text/javascript">
			function getUpdateElements()
			{
				var obj = {
					introduction: document.getElementsByClassName("introduction"),
					fohc: document.getElementsByClassName("fohc"),
					fohh: document.getElementsByClassName("fohh"),
					hohc: document.getElementsByClassName("hohc"),
					hohh: document.getElementsByClassName("hohh")
				};

				return obj; /* Why can't I just return the above object? Syntax error : unexpected */
			}

			var hiddenClassName = "hidden";
			var focusedLinkClassName = "focus-link";

			function introduction_click()
			{
				$(".introduction").removeClass(hiddenClassName);
				$(".introduction").addClass(focusedLinkClassName);

				$(".language").addClass(hiddenClassName);
				$(".language").removeClass(focusedLinkClassName);

				$(".setting").addClass(hiddenClassName);
				$(".setting").removeClass(focusedLinkClassName);

				$(".search-strategy").addClass(hiddenClassName);
				$(".search-strategy").removeClass(focusedLinkClassName);

				$(".logic-comparison").addClass(hiddenClassName);
				$(".logic-comparison").removeClass(focusedLinkClassName);

				$(".examples").addClass(hiddenClassName);
				$(".examples").addClass(focusedLinkClassName);
			}

			function language_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".introduction").removeClass(focusedLinkClassName);				

				$(".language").removeClass(hiddenClassName);
				$(".language").addClass(focusedLinkClassName);

				$(".setting").addClass(hiddenClassName);
				$(".setting").removeClass(focusedLinkClassName);

				$(".search-strategy").addClass(hiddenClassName);
				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").addClass(hiddenClassName);
			}

			function setting_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".introduction").removeClass(focusedLinkClassName);				

				$(".language").addClass(hiddenClassName);
				$(".language").removeClass(focusedLinkClassName);

				$(".setting").removeClass(hiddenClassName);
				$(".setting").addClass(focusedLinkClassName);

				$(".search-strategy").addClass(hiddenClassName);
				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").addClass(hiddenClassName);
			}

			function strategy_click()
			{
				$(".introduction").addClass(hiddenClassName);

				$(".language").addClass(hiddenClassName);
				$(".language").removeClass(focusedLinkClassName);

				$(".setting").addClass(hiddenClassName);

				$(".search-strategy").removeClass(hiddenClassName);
				$(".search-strategy").addClass("focus");

				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").addClass(hiddenClassName);
				// $(".fohc").addClass(hiddenClassName);
				// $(".fohh").addClass(hiddenClassName);
				// $(".hohc").addClass(hiddenClassName);
				// $(".hohh").addClass(hiddenClassName);
			}

			function logic_comparison_click()
			{
				$(".introduction").addClass(hiddenClassName);

				$(".language").addClass(hiddenClassName);
				$(".language").removeClass(focusedLinkClassName);

				$(".setting").addClass(hiddenClassName);
				$(".search-strategy").addClass(hiddenClassName);

				$(".logic-comparison").removeClass(hiddenClassName);
				$(".logic-comparison").addClass("focus-link");

				$(".examples").addClass(hiddenClassName);
			}

			function examples_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".setting").addClass(hiddenClassName);
				$(".language").addClass(hiddenClassName);
				$(".search-strategy").addClass(hiddenClassName);
				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").removeClass(hiddenClassName);
				// $(".fohc").addClass(hiddenClassName);
				// $(".fohh").addClass(hiddenClassName);
				// $(".hohc").addClass(hiddenClassName);
				// $(".hohh").addClass(hiddenClassName);
			}

			function expandRules_click()
			{
				$(".scroll").toggleClass(hiddenClassName);
				$(".open").toggleClass(hiddenClassName);
				$(".closed").toggleClass(hiddenClassName);
				$(".top-container").toggleClass("pad-bottom")
			}
		</script>

	</head>
	<body>
		
		<div class="top-container">

			<div class="menu">
				<div class="menu-container">
					<a class="menu-introduction menu-item" href="#" onclick="introduction_click()">Introduction</a>
					<a class="menu-language menu-item" href="#" onclick="language_click()">Type System</a>
					<a class="menu-setting menu-item" href="#" onclick="setting_click()">Setting</a>
					<a class="menu-logic_comparison menu-item" href="#" onclick="logic_comparison_click()">Logic Comparison</a>
					<a class="menu-strategy menu-item" href="#" onclick="strategy_click()">Search Strategy</a>
					<a class="menu-examples menu-item" href="#" onclick="examples_click()">Examples</a>
				</div>
			</div>

			<div class="introduction frame header">
				<div class="top-title">Programming with Higher Order Logic</div>
				<a class="book-link note-visual" href="https://sites.google.com/site/proghol/">Book by Dale Miller and Gopalan Nadathur</a>
				<div class="presentation-note">***Content in this font is a presentation note only and will be hidden in the final version***</div>
				<div class="todo">***Content in this font is a TODO and will be hidden in the final version***</div>
				<div class="note">
					<span class="subtitle">Presentation Goals:</span>
					<ul>
						<li>Introduce logic as programming via proof search and *substitution* for existentially quantified variables</li>
						<li>Basic idea of differences between different logic programming languages</li>
						<li>Examples of problems that can be solved with logic programming</li>
						<li>Website as artifact for future reference, possibly extended with more explanation for learning the languages</li>
					</ul>
				</div>
				<div class="todo">MAIN TODO LIST:</div>
				<div class="todo">More focus on substitutions as solutions to problems</div>
				<div class="todo">Put title on its own "home" link?</div>
				<div class="todo">Math font vs teletype in examples</div>
				<div class="todo">Visual indication of which menu link is currently selected</div>
				<div class="todo">Add discussion on typing rules? Unification?</div>
				<div class="todo">choose consistent notation... code vs math</div>
				<div class="todo">Add rule side-conditions (in notes, or in rules if time)</div>
				<div class="todo">Area for conventions?</div>
				<div class="todo">Future: unification</div>
				<div class="todo">Future: module system?</div>
				<div class="todo">Arrow through notes?</div>
				<div class="todo">Wikipedia links?</div>
				<div class="todo">Download MathJax</div>
				<div class="todo">Talk about minimal vs intuitionistic logic?</div>
				<div class="todo">Button to toggle visibility of presentation notes?</div>
				<div class="todo">Deal with focused link class names (??)</div>
				<div class="todo">Page of definitions and links throughout page</div>
				<div class="todo">Separate rules into "Goal Reduction" and "Backchaining"</div>
				<div class="todo">Page with instructions on using lambda-prolog, linux, etc</div>
			</div>


<!----------------------------------------
	INTRODUCTION
----------------------------------------->


			<div class="introduction frame">
				<div class="title">Introduction</div>
				<div class="section goal-section">
					<div class="introduction-goal note">
						<span class="subtitle">Objective:</span>
						<div class="note">
							Use (higher-order) typed logic to express relational specifications of computations and construct valid proofs of contextual queries
						</div>
					</div>
					<div class="presentation-note">The first-order and higher-order distinction will be explored more later</div>
					<div class="presentation-note">We're used to defining functions to operate on data, e.g. a function for reversing lists that takes a list as input and returns the passed list reversed, but here we are seeing things relationally; a relation representing list reversal is between two lists, where one is the reverse of the other; usually the last argument represents the "output", but the whole expression is a formula</div>
					<div class="example">
						<span class="subtitle subsub">Example:</span>
						<ul>
							<li>
								Encode terms of type <span class="code">list</span> and predicates to define reversal	
							</li>
							<li>
								<span class="code">reverse L1 L2</span> is true or false and can mean <span class="code">L2</span> is the reverse of <span class="code">L1</span>
							</li>
						</ul>
						<table class="code hidden">
							<tr>
								<td>
									list : type -> type
								</td>
							</tr>
							<tr>
								<td>
									nil : list A
								</td>
							</tr>
							<tr>
								<td>
									cons : A -> list A -> list A
								</td>
							</tr>
						</table>
					</div>
					<div class="example">
						<span class="subtitle subsub">Example:</span>
						<div class="note">	
							Encode and reason about other logics and languages
						</div>
					</div>
				</div>
				<div class="section concerns-section">
					<div class="subtitle">Concerns:</div>
					<ul>
						<li>
							how to define terms and predicates and declare their types
						</li>
						<li>
							how order of a logic impacts computational possibilities
						</li>
						<li>
							what are the structures we reason about and the rules for doing so
						</li>
						<li>
							what does computation look like
						</li>
					</ul>
				</div>
				
				<div class="section approach-section">
					<span class="subtitle">Approach:</span>
					<div class="note">
						Using sequent calculus, computation is goal-directed proof search, so we start with what we want to prove at the root of a proof tree
					</div>
					<div class="note-visual">

						<div class="rule-container">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											<div class="stack">
												<div class="node-row">
													<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-clap"></i>
												</div>
												<div>
													$\vdots$
												</div>		
											</div>
										</div><div class="premise">
											$\dots$
										</div><div class="premise">
											<div class="stack">
												<div class="node-row">
													<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-clap"></i>
												</div>
												<div>
													$\vdots$
												</div>		
											</div>
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									
								</div>
							</div>
							<div class="rule-bottom">
								<div class="node-row">
									<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-question"></i>
								</div>
							</div>
						</div>

					</div>
					<div class="note">
							Contrast this view of computation with:
							<ul class="note">
								<li>
									Computation in functional languages as reductions to a normal form
								</li>
								<li>
									Computation in imperative languages as updates to models of data
								</li>
							</ul>
						</div>
				</div>
			</div>


<!----------------------------------------
	THE TYPE SYSTEM
----------------------------------------->

			<div class="language frame hidden">
				<div class="title">The Type System</div>
				<div class="todo">Better name?</div>

				<div class="section">
					<div class="subtitle">Kinds and Types</div>
					<div class="section outline">
						<div class="note">
							Think of a kind as the type of a type
						</div>
						<div class="todo">visual?</div>

						<div class="note">
							Kind expressions are built from the following grammar:
							<div class="note">
								$$
								\begin{align*}
								\langle \textit{kind expression} \rangle ::=& \; \textit{type} \\
								|& \; \textit{type} \rightarrow \langle \textit{kind expression} \rangle
								\end{align*}
								$$
							</div>
						</div>

						<div class="presentation-note">Kinds are either <span class="code">type</span> or some number of <span class="code">type</span>s with arrows between</div>

						<div class="note">Each type or type constructor is related to a <em>kind expression</em>, declared in a <em>kind</em> declaration:</div>
						<table class="note-visual code code-table">
							<tr>
								<td>
									kind
								</td>
								<td>
									(<em>identifier</em>)
								</td>
								<td>
									(kind expression).
								</td>
							</tr>
							<tr class="example-row">
								<td>
									kind
								</td>
								<td>
									list
								</td>
								<td>
									type -> type.
								</td>
							</tr>
						</table>
						<div class="note">
							We say "<span class="code">list</span> has kind <span class="code">type -> type</span>"
						</div>
						<div class="presentation-note">The example above creates a new type constructor "list" related to the kind "type -> type"</div>
						
						<div class="note">Type constructors related to kind expressions using "$\rightarrow$" allow parametric polymorphism</div>
						<div class="example">The constant <span class="code">list</span>, when applied to a type, is parametric in that "argument" type</div>
						<div class="presentation-note">see page 20/21 for discussion</div>
					</div>

					<div class="subtitle">Types and Terms</div>					
					<div class="section outline">
						<div class="note">Type expressions are built from the following grammar:
							<div class="note">
								$$
								\begin{align*}
								\langle \textit{type expression} \rangle ::=& \; \langle \textit{type variable} \rangle \\
								|& \; \langle \textit{type expression} \rangle \rightarrow \langle \textit{type expression} \rangle \\
								|& \; \langle \textit{type constructor} \rangle \: \langle \textit{type expression} \rangle \: \ldots \: \langle \textit{type expression} \rangle
								\end{align*}
								$$
							</div>
						</div>

						<div class="note">Each term or predicate symbol is related to a <em>type expression</em>, declared in a <em>type</em> declaration:</div>
						<table class="note-visual code code-table">
							<tr>
								<td>
									type
								</td>
								<td>
									(<em>identifier</em>)
								</td>
								<td>
									(type expression).
								</td>
							</tr>
							<tr class="example-row">
								<td>
									type
								</td>
								<td>
									cons
								</td>
								<td>
									A -> list A -> list A.
								</td>
							</tr>
						</table>
						<div class="presentation-note">The example above creates a new term constructor "cons" of type "A -> list A -> list A"</div>
						
						<div class="note">Type expressions using type variables allow polymorphism</div>
						<div class="example"><span class="code">cons</span> is related to the polymorphic type expression <span class="code">A -> list A -> list A</span></div>
						<div class="presentation-note">The constant cons is a polymorphic data constructor to be applied to an element of type A and a list with elements of type A to give a new list of elements of type A</div>

						<div class="note">Type expressions using "$\rightarrow$" allow value constructors for building structured data</div>
						<div class="example"><span class="code">cons</span> can be used to build lists, given an element and a list of appropriate type</div>						
						<div class="note">
							We say "<span class="code">cons</span> has type <span class="code">A -> list A -> list A</span>"
						</div>

						<div class="note">Type espressions using type constructors must be fully applied, so well-formed type expressions are related to the kind <span class="code">type</span></div>
						<div class="example">
							<ul>
								<li>
									<span class="code">list</span>, related to the kind <span class="code">type -> type</span> is not a valid type expression
								</li>
								<li>
									<span class="code">list int</span>, related to the kind <span class="code">type</span>, is a type expression
								</li>
							</ul>
						</div>

					</div>

					<div class="subtitle">Terms and Formulas</div>
					<div class="section outline">
						<div class="note">
							A <em>term</em> is typable according to the typing rules of the logic; it is either:
							<ol>
								<li>
									a fresh variable of appropriate type, either implicitly or explicitly bound by a quantifier
									<div class="presentation-note">(show roles with quantifiers)</div>
								</li>
								<li>
									a constant from the signature with any type variables instantiated (e.g. <span class="code">nil</span> of type <span class="code">list int</span>)
								</li>
								<li>
									an application of a fully-applied term symbol (e.g. <span class="code">cons 1 nil</span>)
								</li>
								<li>
									a lambda-abstraction of a term variable of appropriate type over a term (e.g. <span class="code">(x : list int) \ reverse (cons 1 (cons 2 nil)) x</span>)
								</li>
							</ul>
						</div>

						<div class="note">
							The type $o$ is reserved for predicates and formulas and its use is restricted for different logics (see the description of Context in Setting and Logic Comparison) <span class="todo-urgent">Add links here</span>
						</div>
						<div class="example">
							Declare the predicate reverse as
							<table class="note code">
								<tr>
									<td>type</td>
									<td>reverse</td>
									<td>list A -> list A -> o.</td>
								</tr>
							</table>
						</div>

						<div class="note">Formulas are terms of type $o$</div>
						<div class="example">
							<span class="code">reverse (cons 1 (cons 2 nil)) (cons 2 (cons 1 nil))</span> is a formula
						</div>
					</div>
				</div>

			</div>



<!----------------------------------------
	SETTING
----------------------------------------->


			<div class="setting frame hidden">
				<div class="title">Setting</div>

				<div class="section">
					<div class="subtitle">
						Sequent, <span class="feature">$\Sigma ; \mathcal{P} \longrightarrow G$</span>
					</div>
					<div class="section outline">
						<div class="note">
							Represents state of a computation
						</div>
						
						<div class="presentation-note">
							Compare with state in other paradigms
						</div>
						<div class="note">
							"Goal $G$ is provable from the program $\mathcal{P}$ given the type declarations in the signature $\Sigma$"
						</div>
						<div class="note">
							<span class="subtitle subsub">Note:</span> $\rightarrow$, the function arrow, and $\longrightarrow$, the sequent arrow, are different symbols
						</div>
					</div>
				</div>

				<div class="section">
					<div class="subtitle">
						Signature, <span class="feature">$\Sigma$</span>
					</div>
					<div class="section outline">
						<div class="note">
							Available constants and their associated type expressions
						</div>
						<div class="example">
								<span class="code">nil</span> is a constant of type <span class="code">list A</span> for some type <span class="code">A</span>
						</div>
						<div class="note">
							Initially in the signature:
							<table class="display-table">
								<tr>
									<td>
										Math font
									</td>
									<td>
										Concrete syntax font
									</td>
									<td>
										Type
									</td>
								</tr>
								<tr>
									<td>
										$\top$
									</td>
									<td class="code">
										tt
									</td>
									<td>
										$o$
									</td>
								</tr>
								<tr>
									<td>
										$\wedge$
									</td>
									<td>
										<span class="code">&</span> or <span class="code">,</span>
									</td>
									<td>
										$o \rightarrow o \rightarrow o$
									</td>
								</tr>
								<tr>
									<td>
										$\vee$
									</td>
									<td class="code">
										;
									</td>
									<td>
										$o \rightarrow o \rightarrow o$
									</td>
								</tr>
								<tr>
									<td>
										$\supset$
									</td>
									<td class="code">
										=>
									</td>
									<td>
										$o \rightarrow o \rightarrow o$
									</td>
								</tr>
								<tr>
									<td>
										$\leftarrow$
									</td>
									<td class="code">
										:-
									</td>
									<td>
										$o \rightarrow o \rightarrow o$
									</td>
								</tr>
								<tr>
									<td>
										$\forall$
									</td>
									<td class="code">
										pi
									</td>
									<td>
										$(A \rightarrow o) \rightarrow o$
									</td>
								</tr>
								<tr>
									<td>
										$\exists$
									</td>
									<td class="code">
										sigma
									</td>
									<td>
										$(A \rightarrow o) \rightarrow o$
									</td>
								</tr>
							</table>
							<div class="note">
								<span class="subtitle subsub">Note:</span> <span class="code">-></span> is used in place of $\rightarrow$ as the function arrow in code
							</div>
							
						</div>
						<div class="note">
								The symbol <span class="code">\</span> is used as a binding operator
							</div>
							<div class="example">
								In the term $(f : \tau_1) \backslash (x : \tau_2) \backslash f \; x$, the variable names $f$ and $x$ are bound in the expression $f \; x$
							</div>
							<div class="note">
								Types of bound variables can be inferred and left out of the expression
							</div>
							<div class="example">
								The term $(f : \tau_1) \backslash (x : \tau_2) \backslash f \; x$ can be rewritten as $f \backslash x \backslash f \; x$
							</div>
							<div class="note">
								$\forall (x : T) \, F$ is shorthand for $\forall ((x : T) \, \backslash \, F)$ and $\exists (x : T) \, F$ is shorthand for $\exists ((x : T) \, \backslash \, F)$
							</div>
							<div class="note">
								A variable bound using the binding operator is a <em>term variable</em>
							</div>
						<div class="note">
							Extend the signature using kind and type declarations, as above.
						</div>
						
						<div class="example">
							<table class="code">
								<tr>
									<td>
										kind
									</td>
									<td>
										list
									</td>
									<td>
										type -> type.
									</td>
								</tr>
								<tr>
									<td>
										type
									</td>
									<td>
										nil
									</td>
									<td>
										list A.
									</td>
								</tr>
								<tr>
									<td>
										type
									</td>
									<td>
										cons
									</td>
									<td>
										A -> list A -> list A.
									</td>
								</tr>
								<tr>
									<td>
										type
									</td>
									<td>
										length
									</td>
									<td>
										list A -> int -> o.
									</td>
								</tr>
							</table>
						</div>
					</div>
				</div>
				
				<div class="section">
					<div class="subtitle">
						Program, <span class="feature">$\mathcal{P}$</span>
					</div>
					<div class="section outline">
						<div class="note">
							A set of assumed formulas representing partial definitions of predicates
						</div>
						<div class="example">
							<table class="code">
								<tr>
									<td>
										length nil 0.
									</td>
								</tr>
								<tr>
									<td>
										length (cons H T) (1 + N) :- length T N.
									</td>
								</tr>
							</table>
						</div>
					</div>
				</div>

				<div class="section">
					<div class="subtitle">
						Goal, <span class="feature">$G$</span>
					</div>
					<div class="section outline">
						<div class="note">
							A formula we would like to prove, assuming the formulas in $\mathcal{P}$ and using the constants declared in $\Sigma$
						</div>
						<div class="example">
							<span class="code">sigma M \ length (cons 1 (cons 2 (cons 3 nil))) M.</span>
						</div>

						<div class="note">
							<em>Unification</em> is a process of finding substitutions for variables that simultaneously satisfy a set of equalities
						</div>
						<div class="note">
							Valid substitutions for existential variables found by unification represent a <em>solution</em> to the computation
						</div>

						<div class="note">
							The proof of the example above can be seen in "Search Strategy"
						</div>
					</div>
				</div>
			</div>

<!----------------------------------------
	LOGIC COMPARISON
----------------------------------------->

			<div class="logic-comparison frame hidden">
				<div class="title">Horn Clauses vs Hereditary Harrop Formulas</div>
				<div class="section hc">
					<div class="subtitle">Horn clause grammar:</div>
					<div class="hc-grammar note">
						<div>
							$$
							\begin{align*}
							G ::=& \; \top \;\; | \;\; G \wedge G \;\; | \;\; G \vee G \;\; | \;\; \exists_\tau x \, G \\
							D ::=& \; A \;\; | \;\; G \supset D \;\; | \;\; D \wedge D \;\; | \;\; \forall_\tau x \, D
							\end{align*}
							$$
						</div>
					</div>
				</div>
				<div class="section hh">
					<div class="subtitle">Hereditary Harrop grammar:</div>
					<div class="hh-grammar note">
						<div class="grammar">
							$$
							\begin{align*}
							G ::=& \; \top \;\; | \;\; G \wedge G \;\; | \;\; G \vee G \;\; | \;\; \exists_\tau x \, G \;\; | \;\; D \supset G \;\; | \;\; \forall_\tau x \, G \\
							D ::=& \; A \;\; | \;\; G \supset D \;\; | \;\; D \wedge D \;\; | \;\; \forall_\tau x \, D
							\end{align*}
							$$
						</div>
					</div>
				</div>
				<div class="section">
					<div class="subtitle">Modular programming and hypothetical reasoning:</div>
					<div class="note">
						<ul class="note-list">
							<li>Implication in goals allows program modification during proof search via $\supset_R$ rule</li>
						</ul>
						<div class="todo">example</div>
					</div>
					<div class="subtitle">Generic reasoning:</div>
					<div class="note">
						<ul class="note-list">
							<li>Universal quantification in goals allows context modification during proof search via $\forall_R$ rule</li>
						</ul>
						<div class="todo">example</div>
					</div>
					<div class="presentation-note">Show appropriate rule when discussed</div>
				</div>
			</div>

			<div class="logic-comparison frame hidden">
				<div class="title">First-Order vs. Higher-Order Logic</div>
				<div class="section">
					<div class="subtitle">Type Expression Order</div>
					<div class="note">
						Type expressions constructed from the following grammar (restricted in first-order):
						$$
						\begin{align*}
						\langle \textit{type expression} \rangle ::=& \; \langle \textit{type var} \rangle \\
						|& \; \langle \textit{type expression} \rangle \rightarrow \langle \textit{type expression} \rangle \\
						|& \; \langle \textit{tyc} \rangle \: \langle \textit{type expression} \rangle \: \ldots \: \langle \textit{type expression} \rangle
						\end{align*}
						$$
					</div>
					<div class="note">
						*The grammar above allows higher-order types, but this will be restricted for certain sublogics
					</div>
					<div class="note">
						The order of type expressions is defined as:
						$$
						\begin{align*}
						\textit{ord}(\tau) =& 0, \qquad\qquad \textrm{provided } \tau \textrm{ is non-functional} \\
						\textit{ord}(\tau_1 \rightarrow \tau_2) =& \textit{max}(\textit{ord}(\tau_1) + 1, \textit{ord}(\tau_2))
						\end{align*}
						$$
					</div>
					<div class="note">Informally, order is the maximum number of nested arrows</div>
				</div>
				<div class="section">
					<div class="note">
						<div class="subtitle">First-Order Restrictions:</div>
						<div class="note"><span class="em em-warning"></span>Type expression order $\leq$ 1</div>
						<div class="presentation-note">No functional arguments</div>
						<div class="note"><span class="em em-warning"></span>Type variable substitutions are expressions of order $0$ and not $o$</div>
						<div class="presentation-note">Order of type expressions can be increased and?</div>
						<div class="todo">explain what problem $o$ will cause, increasing order of type expressions?</div>
						<div class="note"><span class="em em-warning"></span>Sort $o$ not used in type expressions except as target type (called a predicate symbol)</div>
						<div class="todo">explain what problem this will cause</div>
						<div class="note"><span class="em em-warning"></span>Type expressions representing type of a term variable must have order $0$ and not be $o$</div>

						<div class="todo">Distinction between formulas and terms somewhere</div>
					</div>
				</div>
			</div>



<!----------------------------------------
	SEARCH STRATEGY
----------------------------------------->

			<div class="search-strategy frame hidden">
				<div class="title">Proof Search Strategy</div>
				<div class="note">The proof search process alternates between goal reduction and backchaining phases</div>
				<div class="subtitle">
					Goal reduction:
				</div>
				<div class="goal-reduction note">
					When the top-level symbol of the goal is a logical constant, use the appropriate right-rule
				</div>
				<div class="example">
					<div class="rule-container rule-root">
						<div class="rule-body">
							<div class="rule-premises">
								<div class="tree-branch">
									<div>$\vdots$</div>
									<div>$\Sigma ; \mathcal{P} \longrightarrow B_1$</div>
								</div>
								<div class="tree-branch">
									<div>$\vdots$</div>
									<div>$\Sigma ; \mathcal{P} \longrightarrow B_2$</div>
								</div>
							</div>
							<div class="rule-conclusion">
								<div>$\Sigma ; \mathcal{P} \longrightarrow B_1 \wedge B_2$</div>
							</div>
							<div class="center-flex">$\vdots$</div>
						</div>
						<div class="rule-name">
							$\wedge_R$
						</div>
					</div>
				</div>
				<div class="goal-reduction note">
					During goal reduction, search process is independent of the context and program
				</div>
				<div class="presentation-note">(Rules visible here; describe how used; explain that or-rule ignored?)</div>
				<div class="subtitle">Backchaining:</div>
				<div class="backchaining note">
					When the goal is atomic, look to the program to continue proof search:
					<ol>
						<li>
							use the <em>decide</em> rule to select a program clause
						</li>
						<li>
							use the <em>backchaining</em> rule on the chosen clause
						</li>
					</ol>
				</div>

				<div class="todo-urgent">Add proof tree</div>

				<div class="note">Proof of $\exists \mathtt{M} \backslash \mathtt{length \; (cons \; 1 \; (cons \; 2 \; (cons \; 3 \; nil))) \; M}$:</div>

				<div class="example">
					<div class="note">
						Let the context $\Sigma$ be augmented with $\mathtt{nil : list \; A}$ and $\mathtt{cons : A \rightarrow list\; A \rightarrow list \; A}$.
					</div>
					<div class="note">
						Let the program be $\mathcal{P} = \{ \mathtt{length \; nil \; 0}, \mathtt{length \; (cons \; H \; T) \; (1 + N) :- length \; T \; N} \}$, the set of predicates defining length of a list.
					</div>
					<div class="note goal-reduction">
						Our initial goal is $\exists \mathtt{M} \backslash \mathtt{length \; (cons \; 1 \; (cons \; 2 \; (cons \; 3 \; nil))) \; M}$. We are in a goal-reduction phase.
					</div>
					<div class="note goal-reduction">
						First use $\exists_R$ to reduce the goal and get the new state $\Sigma ; \mathcal{P} \longrightarrow \mathtt{length \; (cons \; 1 \; (cons \; 2 \; (cons \; 3 \; nil))) \; t}$. We have a side condition that $M = t$. 
					</div>
					<div class="note backchain">
						The new goal is atomic, so backchain choosing the second program clause, $\mathtt{length \; (cons \; H \; T) (1 + N) :- length \; T \; N}$, which we will call $P_2$. The new state is $\Sigma ; \mathcal{P} \overset{P_2}{\longrightarrow} \mathtt{length \; (cons \; 1 \; (cons \; 2 \; (cons \; 3 \; nil))) \; t}$.
					</div>
					<div class="note goal reduction">
						Keeping track of the side condition $t = 1 + N$, use the $\mathit{backchain}$ rule to get the new state $\Sigma ; \mathcal{P} \longrightarrow \mathtt{length \; (cons \; 2 \; (cons \; 3 \; nil)) \; N}$.
					</div>
					<div class="note">
						Backchain two more times to get the substitution $M = 3$ as the solution to the query, once the system of equations of side conditions is solved.
					</div>
				</div>

			</div>


<!----------------------------------------
	EXAMPLES
----------------------------------------->

			<div class="fohc examples frame hidden">
				<div class="title">First-Order Horn Clauses (FOHC)</div>
				<div class="note">
					<span class="subtitle">Binary trees:</span>
					<div class="note">
						Specification of terms and predicate for counting the nodes in the tree.
					</div>
					<div class="example">
						<table class="code">
							<tr>
								<td colspan="3">
									/* Signature declarations: */
								</td>
							</tr>
							<tr>
								<td>
									kind					
								</td>
								<td>
									bintree
								</td>
								<td>
									type -> type.
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									empty
								</td>
								<td>
									bintree A.
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									node
								</td>
								<td>
									A -> bintree A -> bintree A -> bintree A.
								</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td colspan="3">
									/* Program definition: */
								</td>
							</tr>
							<tr>
								<td colspan="3">
									nodeCount empty 0.
								</td>
							</tr>
							<tr>
								<td colspan="3">
									nodeCount (node V T1 T2) (1 + N1 + N2) :- nodeCount T1 N1 & nodeCount T2 N2. 
								</td>
							</tr>
						</table>
					</div>
					<div class="note">
						Example goal: <span class="code">sigma M \ nodeCount (node 1 (node 2 (node 3 empty empty) (node 4 empty empty)) (node 5 empty empty)) M</span>
					</div>
					<div class="note">
						Answer set substitution: <span class="code">M = 5</span>
					</div>
				</div>
			</div>

			<div class="fohh examples frame hidden">
				<div class="title">First-Order Hereditary Harrop Formulas (FOHH)</div>
				<div class="note">
					<span class="subtitle">Encoding horn clauses:</span>
					<div class="note">
						Declare propositional constants of type $o$ and write program clauses to specify relationships between the propositional variables. The implication of the object logic (FOHC) is encoded as implication in the ambient logic (FOHH).
					</div>
					<div class="note">
						Example from p. 78 of <a class="book-link" href="https://sites.google.com/site/proghol/">PwHOL</a>.
					</div>
				
					<div class="example">
							<table class="code">
								<tr>
									<td colspan="3">
										/* Signature declarations: */
									</td>
								</tr>
								<tr>
									<td>
										type
									</td>
									<td>
										q, r, s, t, u
									</td>
									<td>
										o.
									</td>
								</tr>
								<tr class="space-row"></tr>
								<tr>
									<td colspan="3">
										/* Program definition: */
									</td>
								</tr>
								<tr>
									<td colspan="3">
										s :- r, q.
									</td>						
								</tr>
								<tr>
									<td colspan="3">
										t :- q, u.
									</td>
								</tr>
								<tr>
									<td colspan="3">
										q :- r.
									</td>
								</tr>
							</table>
					</div>

					<div class="note">
						Proof of <span class="code">r => s</span>:
					</div>
					<div class="center-flex">
						<div class="rule-container rule-root">
							<div class="rule-body">
								<div class="rule-premises">
									<div class="rule-container">
										<div class="rule-body">
											<div class="rule-premises">
												<div class="rule-container rule_backchain">
													<div class="rule-body">
														<div class="rule-premises">
															<div class="rule-container">
																<div class="rule-body">
																	<div class="rule-premises">
																		<div class="rule-container rule_backchain">
																			<div class="rule-body">
																				<div class="rule-premises">
																					
																				</div>
																				<div class="rule-conclusion">
																					$\Sigma ; \mathcal{P}, r \overset{r}{\longrightarrow} r$
																				</div>
																			</div>
																			<div class="rule-name">
																				initial
																			</div>
																		</div>
																	</div>
																	<div class="rule-conclusion">
																		$\Sigma ; \mathcal{P} , r \longrightarrow r$
																	</div>
																</div>											
																<div class="rule-name">
																	decide
																</div>
															</div>
															<div class="rule-container">
																<div class="rule-body">
																	<div class="rule-premises">
																		<div class="rule-container rule_backchain">
																			<div class="rule-body">
																				<div class="rule-premises">
																					<div class="rule-container rule_backchain">
																						<div class="rule-body">
																							<div class="rule-premises">
																								
																							</div>
																							<div class="rule-conclusion">
																								$\Sigma ; \mathcal{P} , r \overset{r}{\longrightarrow} r$
																							</div>
																						</div>
																						<div class="rule-name">
																							initial
																						</div>
																					</div>
																				</div>
																				<div class="rule-conclusion">
																					$\Sigma ; \mathcal{P} , r \overset{r \supset q}{\longrightarrow} q$
																				</div>
																			</div>
																			<div class="rule-name">
																				backchain
																			</div>
																		</div>
																	</div>
																	<div class="rule-conclusion">
																		$\Sigma ; \mathcal{P} , r \longrightarrow q$
																	</div>
																</div>
																<div class="rule-name">
																	decide
																</div>
															</div>
														</div>
														<div class="rule-conclusion">
															$\Sigma ; \mathcal{P} , r \overset{(r \wedge q) \supset s}{\longrightarrow} s$
														</div>
													</div>
													<div class="rule-name">
														backchain
													</div>
												</div>
											</div>
											<div class="rule-conclusion">
												$\Sigma ; \mathcal{P} , r \longrightarrow s$
											</div>
										</div>
										<div class="rule-name">
											decide
										</div>	
									</div>
								</div>
								<div class="rule-conclusion">
									$\Sigma; \mathcal{P} \longrightarrow r \supset s$
								</div>	
							</div>
							<div class="rule-name">
								$\supset_R$
							</div>
						</div>
					</div>
					
				</div>
				<div class="todo">some proof explanation</div>
				<div class="todo">Reference example from book</div>
			</div>

			<div class="hohc examples frame hidden">
				<div class="title">Higher-Order Horn Clauses (HOHC)</div>
				<div class="note">
					<span class="subtitle">Higher-order predicate</span>
					<div class="note">
						Filter a list by items that are flagged using a higher-order predicate. We call this predicate <span class="code">sublist</span> and it takes a functional argument (order > 1) representing a polymorphic formula.
					</div>
					<div class="note">
						<span class="code">sublist</span> definition from p. 127 of <a class="book-link" href="https://sites.google.com/site/proghol/">PwHOL</a>.
					</div>
				
					<div class="example">
						<table class="code">
							<tr>
								<td colspan="3">
									/* Signature declarations: */
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									sublist
								</td>
								<td>
									(A -> o) -> list A -> list A -> o.
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									flagged
								</td>
								<td>
									A -> o.
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									v, w, x, y, z
								</td>
								<td>
									A.
								</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td colspan="3">
									/* Program definition: */
								</td>
							</tr>
							<tr>
								<td colspan="3">
									sublist P (X :: L) (X :: K) :- P X, sublist P L K.
								</td>
							</tr>
							<tr>
								<td colspan="3">
									sublist P (X :: L) K :- sublist P L K.
								</td>
							</tr>
							<tr>
								<td colspan="3">
									sublist P nil nil.
								</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td colspan="3">
									flagged x, flagged y, flagged z.
								</td>
							</tr>
						</table>
					</div>
					<div class="note">
						Example goal: <span class="code">sigma L \ sublist flagged (cons v (cons w (cons x (cons y (cons z nil))))) L</span>
					</div>
					<div class="note">
						Answer set substitution: <span class="code">L = cons x (cons y (cons z nil))</span>
					</div>
				</div>

			</div>

			<div class="hohh examples frame hidden">
				<div class="title">Higher-Order Hereditary Harrop Formulas (HOHH)</div>
				<div class="note">
					<div class="subtitle">Encoding type inference for a fragment of minimal logic</div>
					<div class="note">
						<ul>
							<li>
								Declare a kind for object logic types and types for object logic type constructors
							</li>
							<li>
								Declare a kind for object logic expressions and types for application and abstraction and a predicate for typing 
							</li>
							<li>
								Declare a type representing object logic typing
							</li>
							<li>
								Write program clauses to specify the type inference rules
							</li>
						</ul>
						<div class="note">
							Higher-order: The type of <span class="code">fun</span>, the constant representing function abstraction, has order 2
						</div>
						<div class="note">
							Hereditary Harrop: The goal in the second <span class="code">tp_pred</span> predicate specification has universal quantification and implication in the goal
						</div>
						<div class="note">
							Example modified from p. 103 of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a> by B. Pierce. Discussion of a similar encoding using higher-order abstract syntax can be found on p. 17 of <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.157.608&rep=rep1&type=pdf">Hybrid: A Definitional Two-Level Approach to Reasoning with Higher-Order Abstract Syntax</a> by A. Felty and A. Momigliano.
						</div>
					</div>
					<div class="example">
						<table class="code">
							<tr>
								<td colspan="3">
									/* Signature declarations: */
								</td>
							</tr>
							<tr>
								<td>kind</td>
								<td>tp</td>
								<td>type.</td>
							</tr>
							<tr>
								<td>type</td>
								<td>basetp</td>
								<td>tp.</td>
							</tr>
							<tr>
								<td>type</td>
								<td>arr</td>
								<td>tp -> tp -> tp.</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td>kind</td>
								<td>expr</td>
								<td>type.</td>	
							</tr>
							<tr>
								<td>type</td>
								<td>app</td>
								<td>expr -> expr -> expr.</td>
							</tr>
							<tr>
								<td>type</td>
								<td>fun</td>
								<td>(expr -> expr) -> expr.</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td>type</td>
								<td>tp_pred</td>
								<td>expr -> tp -> o.</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td colspan="3">
									/* Program definition: */
								</td>
							</tr>
							<tr>
								<td colspan="3">
									tp_pred (app E1 E2) T1 :- tp_pred E1 (arr T2 T1) & tp_pred E2 T2.
								</td>
							</tr>
							<tr>
								<td colspan="3">
									tp_pred (fun (x \ E x)) (arr T1 T2) :- pi x \ (tp_pred x T1 => tp_pred (E x) T2).
								</td>
							</tr>
						</table>
					</div>
					<div class="note">
						Example goal: <span class="code">sigma T \ tp_pred (fun (f \ (fun (x \ (app f x))))) T</span>
					</div>
					<div class="note">
						Answer set substitution: <span class="code">T = arr (arr T1 T2) (arr T1 T2)</span>
					</div>
					<div class="note">We find that the Church numeral for 1, $\lambda f \lambda x (f \; x)$, has type $(T_1 \rightarrow T_2) \rightarrow T_1 \rightarrow T_2$</div>
				</div>
			</div>

			

		</div>

		<div class="dock-bottom">
				<button class="collapsible" onclick="expandRules_click()">
					<div class="closed"><span class="em em-arrow_forward"></span></div>
					<div class="open hidden"><span class="em em-arrow_down_small"></span></div>
					<span class="subtitle">Inference Rules</span>
					<span class="em em-hammer_and_wrench"></span>
				</button>
				<div class="scroll hidden">
					<div class="note subtitle subsub">
						Right rules:
					</div>
					<div class="rules right-rules">

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\top_R$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow \top$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$\Sigma ; \mathcal{P} \longrightarrow B_1$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\vee_{R_1}$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow B_1 \vee B_2$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$\Sigma ; \mathcal{P} \longrightarrow B_2$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\vee_{R_2}$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow B_1 \vee B_2$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$\Sigma ; \mathcal{P} \longrightarrow B_1$
										</div><div class="premise">
											$\Sigma ; \mathcal{P} \longrightarrow B_2$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\wedge_R$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow B_1 \wedge B_2$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$\Sigma ; \mathcal{P} , B_1 \longrightarrow B_2$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\supset_R$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow B_1 \supset B_2$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									{$c$ fresh}
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$c : \tau , \Sigma ; \mathcal{P} \longrightarrow B[c/x]$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\forall_R$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow \forall_\tau x \; B$
							</div>
						</div>

						<div class="rule-container rule-root">
							<div class="rule-top">
								<div class="rule-text-left rule-text">
									
								</div>
								<div class="rule-top-center">
									<div class="premise-container">
						  				<div class="premise">
											$\Sigma ; \mathcal{P} \longrightarrow B[t/x]$
										</div><div class="premise">
											$\Sigma ; \Gamma \models t : \tau$
										</div>
						  			</div>
									<div class="divider">
									</div>
								</div>
								<div class="rule-text-right rule-text">
									$\exists_R$
								</div>
							</div>
							<div class="rule-bottom">
								$\Sigma ; \mathcal{P} \longrightarrow \exists_\tau x \; B$
							</div>
						</div>

					</div>

					<div class="note subtitle subsub">
						Left rules:
					</div>
					<div class="rules left-rules">

					<div class="rule-container rule-root">
						<div class="rule-top">
							<div class="rule-text-left rule-text">
								{$D \in \mathcal{P}$}
							</div>
							<div class="rule-top-center">
								<div class="premise-container">
					  				<div class="premise">
										$\Sigma ; \mathcal{P} \overset{D}{\longrightarrow} A$
									</div>
					  			</div>
								<div class="divider">
								</div>
							</div>
							<div class="rule-text-right rule-text">
								decide
							</div>
						</div>
						<div class="rule-bottom">
							$\Sigma ; \mathcal{P} \longrightarrow A$
						</div>
					</div>
						
					<div class="rule-container rule-root">
						<div class="rule-top">
							<div class="rule-text-left rule-text">
								
							</div>
							<div class="rule-top-center">
								<div class="premise-container">
					  				
					  			</div>
								<div class="divider">
								</div>
							</div>
							<div class="rule-text-right rule-text">
								initial
							</div>
						</div>
						<div class="rule-bottom">
							$\Sigma ; \mathcal{P} \overset{A}{\longrightarrow} A$
						</div>
					</div>

					<div class="rule-container rule-root">
						<div class="rule-top">
							<div class="rule-text-left rule-text">
								
							</div>
							<div class="rule-top-center">
								<div class="premise-container">
					  				<div class="premise">
										$\Sigma ; \mathcal{P} \longrightarrow A_1$
									</div><div class="premise">
										$\dots$
									</div><div class="premise">
										$\Sigma ; \mathcal{P} \longrightarrow A_n$
									</div>
					  			</div>
								<div class="divider">
								</div>
							</div>
							<div class="rule-text-right rule-text">
								backchain
							</div>
						</div>
						<div class="rule-bottom">
							$\Sigma ; \mathcal{P} \overset{\forall_{\tau_1} x_1 ... \forall_{\tau_m} x_m (A_1 \wedge \dots \wedge A_n \supset A_0)}{\longrightarrow} A$
						</div>
					</div>

					</div>
				</div>
			</div>

		<div class="typing-rules rules hidden">typing rules</div>
	</body>
</html>

