<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<title>Learn Lambda Prolog!</title>
		<link href="styles/style.css" rel="stylesheet" type="text/css">

		<script type="text/javascript" src="jquery.js"></script>

		<link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet">

		<!--
		Fonts:
			Title: Playfair Display
			Headings: Open Sans Bold
			Emphasized points, bullets: Slabo 27px
			Open Sans Condensed Light
			Lobster Two
		-->

		<!-- Remove unused fonts; Open+Sans:400,700|Open+Sans+Condensed:300|Playfair+Display|-->

		<link href="https://fonts.googleapis.com/css?family=Roboto|Slabo+27px|Lobster+Two" rel="stylesheet">

		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				tex2jax: { inlineMath : [['$','$'], ['\\(','\\)']] },
				"HTML-CSS" : { preferredFont : "STIX" }
			});
		</script>

		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


		<script type="text/javascript">
			function getUpdateElements()
			{
				var obj = {
					introduction: document.getElementsByClassName("introduction"),
					fohc: document.getElementsByClassName("fohc"),
					fohh: document.getElementsByClassName("fohh"),
					hohc: document.getElementsByClassName("hohc"),
					hohh: document.getElementsByClassName("hohh")
				};

				return obj; /* Why can't I just return the above object? Syntax error : unexpected */
			}

			var hiddenClassName = "hidden";
			var focusedLinkClassName = "focus-link";

			function introduction_click()
			{
				$(".introduction").removeClass(hiddenClassName);
				$(".introduction").addClass(focusedLinkClassName);

				$(".setting").addClass(hiddenClassName);
				$(".setting").removeClass(focusedLinkClassName);

				$(".search-strategy").addClass(hiddenClassName);
				$(".search-strategy").removeClass(focusedLinkClassName);

				$(".logic-comparison").addClass(hiddenClassName);
				$(".logic-comparison").removeClass(focusedLinkClassName);

				$(".examples").addClass(hiddenClassName);
				$(".examples").addClass(focusedLinkClassName);
			}

			function setting_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".introduction").removeClass(focusedLinkClassName);				

				$(".setting").removeClass(hiddenClassName);
				$(".setting").addClass(focusedLinkClassName);

				$(".search-strategy").addClass(hiddenClassName);
				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").addClass(hiddenClassName);
			}

			function strategy_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".setting").addClass(hiddenClassName);

				$(".search-strategy").removeClass(hiddenClassName);
				$(".search-strategy").addClass("focus");

				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").addClass(hiddenClassName);
				// $(".fohc").addClass(hiddenClassName);
				// $(".fohh").addClass(hiddenClassName);
				// $(".hohc").addClass(hiddenClassName);
				// $(".hohh").addClass(hiddenClassName);
			}

			function logic_comparison_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".setting").addClass(hiddenClassName);
				$(".search-strategy").addClass(hiddenClassName);

				$(".logic-comparison").removeClass(hiddenClassName);
				$(".logic-comparison").addClass("focus-link");

				$(".examples").addClass(hiddenClassName);
			}

			function examples_click()
			{
				$(".introduction").addClass(hiddenClassName);
				$(".setting").addClass(hiddenClassName);
				$(".search-strategy").addClass(hiddenClassName);
				$(".logic-comparison").addClass(hiddenClassName);
				$(".examples").removeClass(hiddenClassName);
				// $(".fohc").addClass(hiddenClassName);
				// $(".fohh").addClass(hiddenClassName);
				// $(".hohc").addClass(hiddenClassName);
				// $(".hohh").addClass(hiddenClassName);
			}

			function expandRules_click()
			{
				$(".scroll").toggleClass(hiddenClassName);
				$(".open").toggleClass(hiddenClassName);
				$(".closed").toggleClass(hiddenClassName);
			}
		</script>

	</head>
	<body>
		
		<div class="top-container">

			<div class="menu">
				<div class="menu-container">
					<a class="menu-introduction menu-item" href="#" onclick="introduction_click()">Introduction</a>
					<a class="menu-setting menu-item" href="#" onclick="setting_click()">Setting</a>
					<a class="menu-strategy menu-item" href="#" onclick="strategy_click()">Search Strategy</a>
					<a class="menu-logic_comparison menu-item" href="#" onclick="logic_comparison_click()">Logic Comparison</a>
					<a class="menu-examples menu-item" href="#" onclick="examples_click()">Examples</a>
				</div>
			</div>

			<div class="hidden">
				Todo and presentation notes
				<ul>
					<li>best way to structure document and id and class names? don't style based on id; use unique class names; always use class name</li>
					<li>best development tools?</li>
					<li>too many class names? what is proper form? </li>
					<li>dock sequent to top</li>
					<li>on element selection, will need functions to also hilight the related objects</li>
					<li>switch to grid layout for rules container?</li>
					<li>minimize sections?</li>
					<li>download MathJax?</li>
					<li>need distinction between grammars and typing rules for first-order and higher-order</li>
					<li>in future, add conventions</li>
					<li>start with simple examples for concepts, show cool examples for later material to build interest?</li>
					<li>notes about intuitionistic, minimal logic</li>
					<li>pop-up things when term clicked</li>
				</ul>
			</div>

			<div class="introduction frame header">
				<div class="top-title">Programming with Higher Order Logic</div>
				<a class="book-link note-visual" href="https://sites.google.com/site/proghol/">Book by Dale Miller and Gopalan Nadathur</a>
				<div class="presentation-note">***Content in this font is a presentation note only and will be hidden in the final version***</div>
				<div class="todo">***Content in this font is a TODO and will be hidden in the final version***</div>
				<div class="presentation-note">
					Presentation goal:
					<ul>
						<li>Introduce logic as programming via proof search and *substitution*</li>
						<li>Basic idea of differences between different logic programming languages</li>
						<li>Examples of problems that can be solved (elegantly?) with logic programming, most as basic as possible to present idea quickly, one more complicated example requiring hohh (show a proof/computation?)</li>
						<li>Website as artifact for future reference, possibly extended with more explanation for learning the languages</li>
					</ul>
				</div>
				<div class="todo">More focus on substitutions as solutions to problems</div>
				<div class="todo">Put title on its own "home" link?</div>
				<div class="todo">Math font vs teletype in examples</div>
				<div class="todo">Visual indication of which menu link is currently selected</div>
				<div class="todo">Add discussion on typing rules? Unification?</div>
				<div class="todo">Earlier sample run to show how goals used?</div>
				<div class="todo">choose consistent notation... code vs math</div>
				<div class="todo">Add rule side-conditions</div>
				<div class="todo">Area for conventions?</div>
				<div class="todo">Future: unification</div>
				<div class="todo">Future: module system?</div>
			</div>

			<div class="introduction frame last-frame">
				<div class="section">
					<div class="title">Introduction</div>
					<div class="introduction-goal note">
						<span class="subtitle">Goal:</span> use (higher-order) logic to express specifications of computations
					</div>
					<div class="example">
						<span class="subtitle">Example:</span> Encode terms of type <span class="code">list</span> and predicates for reversal, concatenation, filtering, etc
						<table class="code">
							<tr>
								<td>
									list : type -> type
								</td>
							</tr>
							<tr>
								<td>
									nil : list A
								</td>
							</tr>
							<tr>
								<td>
									cons : A -> list A -> list A
								</td>
							</tr>
						</table>
					</div>
					<div class="example">Encode and reason about other logics and languages</div>
				</div>
				<div class="section">
					<div class="presentation-note">
						<div class="subtitle">Considerations:</div>
						<div class="note">
							<ul>
								<li>
									how to define terms and predicates and their types
								</li>
								<li>
									how order of a logic impacts computational possibilities
								</li>
								<li>
									what are the structures we reason about and the rules for doing so
								</li>
								<li>
									what does computation look like
								</li>
							</ul>
						</div>
					</div>
					<div class="todo">Are all of these answered in the website/talk?</div>
				</div>
				<div class="section">
					<div class="introduction-approach note">
						<span class="subtitle">Approach:</span> using sequent calculus, computation is goal-directed proof search
					</div>
					<div class="note-visual">
						<div class="rule-body">
							<div class="rule-premises">
								<div class="tree-branch">
									<div class="tree-symbols rule-conclusion">
										<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-clap"></i>
									</div>
									<div>
										$\vdots$
									</div>
								</div>
								<div>$\ldots$</div>
								<div class="tree-branch">
									<div class="tree-symbols rule-conclusion">
										<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-clap"></i>
									</div>
									<div>
										$\vdots$
									</div>
								</div>
							</div>
							<div class="tree-symbols rule-conclusion">
								<i class="em em-card_file_box"></i>$\longrightarrow$<i class="em em-question"></i>
							</div>
						</div>
					</div>
					<div class="note">
						Substitutions for existential variables represent a $\textit{solution}$ to the computation
					</div>
					<div class="todo">Leave out above to avoid talking about implicit existential vars at this point?</div>
				</div>
			</div>

			<div class="setting frame last-frame hidden">
				<div class="title">Setting</div>

				<div class="section">
					<div class="subtitle">Kinds, Types, Terms, and Formulas</div>
					<div class="section">
						<div class="note">Each type or type constructor is related to a <em>kind expression</em>, declared in a <em>kind</em> declaration:</div>
						<table class="note-visual code display-table">
							<tr>
								<td>
									kind
								</td>
								<td>
									(<em>identifier</em>)
								</td>
								<td>
									(kind expression).
								</td>
							</tr>
							<tr class="example-row">
								<td>
									kind
								</td>
								<td>
									list
								</td>
								<td>
									type -> type.
								</td>
							</tr>
						</table>
						<div class="presentation-note">The example above creates a new type constructor "list" related to the kind "type -> type"</div>
						<div class="note">Kind expressions are built from the following grammar:</div>
						<div class="note">
							$$
							\begin{align*}
							\langle \textit{kind expression} \rangle ::=& \; \textit{type} \\
							|& \; \textit{type} \rightarrow \langle \textit{kind expression} \rangle
							\end{align*}
							$$
						</div>
						<div class="note">Kind expressions using "$\rightarrow$" allow parametrization of types</div>
					</div>
					<div class="section">
						<div class="note">Each term or predicate symbol is related to a <em>type expression</em>, declared in a <em>type</em> declaration:</div>
						<table class="note-visual code display-table">
							<tr>
								<td>
									type
								</td>
								<td>
									(<em>identifier</em>)
								</td>
								<td>
									(type expression).
								</td>
							</tr>
							<tr class="example-row">
								<td>
									type
								</td>
								<td>
									cons
								</td>
								<td>
									A -> list A -> list A.
								</td>
							</tr>
						</table>
						<div class="presentation-note">The example above creates a new term constructor "cons" of type "A -> list A -> list A"</div>
						<div class="note">Type expressions are built from the following grammar:</div>
						<div class="note">
							$$
							\begin{align*}
							\langle \textit{type expression} \rangle ::=& \; \langle \textit{type variable} \rangle \\
							|& \; \langle \textit{type expression} \rangle \rightarrow \langle \textit{type expression} \rangle \\
							|& \; \langle \textit{type constructor} \rangle \: \langle \textit{type expression} \rangle \: \ldots \: \langle \textit{type expression} \rangle
							\end{align*}
							$$
						</div>
						<div class="note">Gramamr above allows higher-order types, but this will be restricted for certain sublogics</div>
						<div class="note">Type expressions using type variables allow polymorphism</div>
						<div class="note">A <em>sort</em> is a zero-arity type constructor (unanalyzable type)</div>
						<div class="note">Well-formed type expressions are related to the kind <span class="code">type</span></div>
						<div class="presentation-note">Well-formed type expressions must have any type constructors present be fully applied</div>
						<div class="todo">Introduce terminology "target type", "argument type", "functional type", "primitive type"?</div>
					</div>
					<div class="todo">How to construct terms, formulas; mention what "$o$" is... need to discuss fo vs ho first?</div>
					<div class="note">A term related to a type expression using $\rightarrow$ is called a <em>value constructor</em> and can be used to build structured data</div>
					<div class="todo">Add an example here?</div>
					<div class="todo">Discuss term variables, after structure of terms? Need to have introduced form of terms and formulas to talk about quantification</div>
				</div>

				<div class="section">
					<div class="subtitle">
						Sequent, <span class="feature">$\Sigma ; \mathcal{P} \longrightarrow G$</span>
					</div>
					<div class="note">
						Represents state of a computation
					</div>
					<div class="note">
						Goal $G$ is provable from the program $\mathcal{P}$ given the type declarations in the signature $\Sigma$
					</div>
					<div class="note">
						<span class="subtitle">NOTE:</span> $\rightarrow$, the function arrow, and $\longrightarrow$, the sequent arrow, are different symbols
					</div>
				</div>

				<div class="section">
					<div class="subtitle">
						Signature, <span class="feature">$\Sigma$</span>
					</div>
					<div class="note">
						Available constants and their associated type expressions
					</div>
					<div class="example">
							<span class="code">nil</span> is a constant of type <span class="code">list A</span> for some type <span class="code">A</span>
					</div>
					<div class="note">
						Initially:
						<ul>
							<li>$\top : o$</li>
							<li>$\wedge : o \rightarrow o \rightarrow o$</li>
							<li>$\vee : o \rightarrow o \rightarrow o$</li>
							<li>$\supset : o \rightarrow o \rightarrow o$</li>
							<li>$\forall : (\tau \rightarrow o) \rightarrow o$</li>
							<li>$\exists : (\tau \rightarrow o) \rightarrow o$</li>
						</ul>
					</div>
					<div class="note">
						Extend using a type declaration (as above).
					</div>
					
					
					<div class="note">
						When necessary, define new types using a kind declaration (as above).
					</div>
					
				</div>
				
				<div class="section">
					<div class="subtitle">
						Program, <span class="feature">$\mathcal{P}$</span>
					</div>
					<div class="note">
						A set of assumed formulas representing partial definitions of predicates
						(TODO: example)
					</div>
				</div>

				<div class="section">
					<div class="subtitle">
						Goal, <span class="feature">$G$</span>
					</div>
					<div class="note">
						A formula we would like to prove, assuming the formulas in $\mathcal{P}$ and using the constants declared in $\Sigma$ (TODO: example)
					</div>
					<div class="todo">
						(see section 2.2)
					</div>
				</div>
			</div>

			<div class="search-strategy frame last-frame hidden">
				<div class="title">Proof Search Strategy</div>
				<div class="subtitle">
					Goal reduction:
				</div>
				<div class="goal-reduction note">
					When the top-level symbol of the goal is a logical constant, use the appropriate right-rule
				</div>
				<div class="example">
					<div class="rule-container">
						<div class="rule-body">
							<div class="rule-premises">
								<div class="tree-branch">
									<div>$\vdots$</div>
									<div>$\Sigma ; \Gamma \longrightarrow B_1$</div>
								</div>
								<div class="tree-branch">
									<div>$\vdots$</div>
									<div>$\Sigma ; \Gamma \longrightarrow B_2$</div>
								</div>
							</div>
							<div class="rule-conclusion">
								<div>$\Sigma ; \Gamma \longrightarrow B_1 \wedge B_2$</div>
								<div>$\vdots$</div>
							</div>
						</div>
						<div class="rule-name">
							$\wedge_R$
						</div>
					</div>
				</div>
				<div class="goal-reduction note">
					Search process is independent of the context and program
				</div>
				<div class="todo">Rules visible here; describe how used; explain that or-rule ignored?</div>
				<div class="subtitle">Backchaining:</div>
				<div class="backchaining note">
					When the goal is atomic, look to the program to continue proof search
				</div>
				<div class="todo">Need example here</div>
				<div class="todo">Note about substitution as solution to search</div>
			</div>

			<div class="logic-comparison frame hidden">
				<div class="title">Horn Clauses vs Hereditary Harrop Formulas</div>
				<div class="section hc">
					<div class="subtitle">Horn clause grammar:</div>
					<div class="hc-grammar note">
						<div>
							$$
							\begin{align*}
							G ::=& \; \top \;\; | \;\; G \wedge G \;\; | \;\; G \vee G \;\; | \;\; \exists_\tau x \, G \\
							D ::=& \; A \;\; | \;\; G \supset D \;\; | \;\; D \wedge D \;\; | \;\; \forall_\tau x \, D
							\end{align*}
							$$
						</div>
					</div>
				</div>
				<div class="section hh">
					<div class="subtitle">Hereditary Harrop grammar:</div>
					<div class="hh-grammar note">
						<div class="grammar">
							$$
							\begin{align*}
							G ::=& \; \top \;\; | \;\; G \wedge G \;\; | \;\; G \vee G \;\; | \;\; \exists_\tau x \, G \;\; | \;\; D \supset G \;\; | \;\; \forall_\tau x \, G \\
							D ::=& \; A \;\; | \;\; G \supset D \;\; | \;\; D \wedge D \;\; | \;\; \forall_\tau x \, D
							\end{align*}
							$$
						</div>
					</div>
				</div>
				<div class="section">
					<div class="subtitle">Modular programming:</div>
					<div class="note">
						<ul class="note-list">
							<li>Implication in goals allows program modification during proof search via $\supset_R$ rule</li>
						</ul>
						<div class="todo">example</div>
					</div>
					<div class="subtitle">Hypothetical reasoning:</div>
					<div class="note">
						<ul class="note-list">
							<li>Universal quantification in goals allows context modification during proof search via $\forall_R$ rule</li>
						</ul>
						<div class="todo">example</div>
					</div>
					<div class="presentation-note">Show appropriate rule when discussed</div>
				</div>
			</div>

			<div class="logic-comparison frame last-frame hidden">
				<div class="title">First-Order vs. Higher-Order Logic</div>
				<div class="section">
					<div class="subtitle">Type Expression Order</div>
					<div class="note">
						Type expressions constructed from the following grammar (restricted in first-order):
						$$
						\begin{align*}
						\langle \textit{type expression} \rangle ::=& \; \langle \textit{type var} \rangle \\
						|& \; \langle \textit{type expression} \rangle \rightarrow \langle \textit{type expression} \rangle \\
						|& \; \langle \textit{tyc} \rangle \: \langle \textit{type expression} \rangle \: \ldots \: \langle \textit{type expression} \rangle
						\end{align*}
						$$
					</div>
					<div class="note">
						The order of type expressions is defined as:
						$$
						\begin{align*}
						\textit{ord}(\tau) =& 0, \qquad\qquad \textrm{provided } \tau \textrm{ is non-functional} \\
						\textit{ord}(\tau_1 \rightarrow \tau_2) =& \textit{max}(\textit{ord}(\tau_1) + 1, \textit{ord}(\tau_2))
						\end{align*}
						$$
					</div>
					<div class="note">Informally, order is the maximum number of nested arrows</div>
				</div>
				<div class="section">
					<div class="note">
						<div class="subtitle">First-Order Restrictions:</div>
						<div class="note"><span class="em em-warning"></span>Type expression order $\leq$ 1</div>
						<div class="presentation-note">No functional arguments</div>
						<div class="note"><span class="em em-warning"></span>Type variable substitutions are expressions of order $0$ and not $o$</div>
						<div class="presentation-note">Order of type expressions can be increased and?</div>
						<div class="todo">explain what problem $o$ will cause, increasing order of type expressions?</div>
						<div class="note"><span class="em em-warning"></span>Sort $o$ not used in type expressions except as target type (called a predicate symbol)</div>
						<div class="todo">explain what problem this will cause</div>
						<div class="note"><span class="em em-warning"></span>Type expressions representing type of a term variable must have order $0$ and not be $o$</div>

						<div class="todo">Distinction between formulas and terms somewhere</div>
					</div>
				</div>
			</div>

			<div class="examples frame hidden todo">
				<div class="todo">TODO: fill in details of examples; definitions for all, and one computation</div>
				<div class="todo">Select one example for each logic?</div>
			</div>

			<div class="fohc examples frame hidden">
				<div class="title">First-Order Horn Clauses (FOHC)</div>
				<div class="note">
					<span class="subtitle">Binary trees:</span> specification of terms and predicate for <span class="todo">pick predicate example</span>
				</div>
				<div class="example">
					<table class="code">
						<tr>
							<td colspan="3">
								/* Signature declarations: */
							</td>
						</tr>
						<tr>
							<td>
								kind					
							</td>
							<td>
								bintree
							</td>
							<td>
								type -> type.
							</td>
						</tr>
						<tr>
							<td>
								type
							</td>
							<td>
								empty
							</td>
							<td>
								bintree A.
							</td>
						</tr>
						<tr>
							<td>
								type
							</td>
							<td>
								node
							</td>
							<td>
								A -> bintree A -> bintree A -> bintree A.
							</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td colspan="3">
								/* Program definition: */
							</td>
						</tr>
						<tr>
							<td colspan="3">
								nodeCount (node V T1 T2) (1 + N1 + N2) :- nodeCount T1 N1 & nodeCount T2 N2. 
							</td>
						</tr>
					</table>
					<div class="todo">Draw the tree?</div>
					<div class="todo">Give goal?</div>
				</div>Your login is incorrect. Please try again
			</div>

			<div class="fohh examples frame hidden">
				<div class="title">First-Order Hereditary Harrop Formulas (FOHH)</div>
				<div class="note">
					<span class="subtitle">Encoding predicate logic:</span> <span class="todo">finish this example... (uses implication for predicate logic implication)</span>
				</div>
				<div class="example">
						<table class="code">
							<tr>
								<td colspan="3">
									/* Signature declarations: */
								</td>
							</tr>
							<tr>
								<td>
									type
								</td>
								<td>
									q, r, s, t, u
								</td>
								<td>
									o.
								</td>
							</tr>
							<tr class="space-row"></tr>
							<tr>
								<td colspan="3">
									/* Program definition: */
								</td>
							</tr>
							<tr>
								<td colspan="3">
									s :- r, q.
								</td>						
							</tr>
							<tr>
								<td colspan="3">
									t :- q, u.
								</td>
							</tr>
							<tr>
								<td colspan="3">
									q :- r.
								</td>
							</tr>
						</table>
				</div>

				<div class="subtitle">Proof of <span class="code">s :- r</span>:</div>
				<div class="todo">Major overhaul of rule/proof layout in styles and possibly structure; more thought needed</div>
				<div class="rule-container">
					<div class="rule-body">
						<div class="rule-premises">
							<div class="rule-container">
								<div class="rule-body">
									<div class="rule-premises">
										<div class="rule-container">
											<div class="rule-body">
												<div class="rule-premises">
													<div class="rule-container">
														<div class="rule-body">
															<div class="rule-premises">
																<div class="rule-container">
																	<div class="rule-body">
																		<div class="rule-premises">
																			
																		</div>
																		<div class="rule-conclusion">
																			$\Sigma ; \mathcal{P}, r \overset{r}{\longrightarrow} r$
																		</div>
																	</div>
																	<div class="rule-name">
																		initial
																	</div>
																</div>
															</div>
															<div class="rule-conclusion">
																$\Sigma ; \mathcal{P} , r \longrightarrow r$
															</div>
														</div>											
														<div class="rule-name">
															decide
														</div>
													</div>
													<div class="rule-container">
														<div class="rule-body">
															<div class="rule-premises">
																<div class="rule-container">
																	<div class="rule-body">
																		<div class="rule-premises">
																			<div class="rule-container">
																				<div class="rule-body">
																					<div class="rule-premises">
																						
																					</div>
																					<div class="rule-conclusion">
																						$\Sigma ; \mathcal{P} , r \longrightarrow r$
																					</div>
																				</div>
																				<div class="rule-name">
																					initial
																				</div>
																			</div>
																		</div>
																		<div class="rule-conclusion">
																			$\Sigma ; \mathcal{P} , r \overset{r \supset q}{\longrightarrow} q$
																		</div>
																	</div>
																	<div class="rule-name">
																		backchain
																	</div>
																</div>
															</div>
															<div class="rule-conclusion">
																$\Sigma ; \mathcal{P} , r \longrightarrow q$
															</div>
														</div>
														<div class="rule-name">
															decide
														</div>
													</div>
												</div>
												<div class="rule-conclusion">
													$\Sigma ; \mathcal{P} , r \overset{(r \wedge q) \supset s}{\longrightarrow} s$
												</div>
											</div>
											<div class="rule-name">
												backchain
											</div>
										</div>
									</div>
									<div class="rule-conclusion">
										$\Sigma ; \mathcal{P} , r \longrightarrow s$
									</div>
								</div>
								<div class="rule-name">
									decide
								</div>	
							</div>
						</div>
						<div class="rule-conclusion">
							$\Sigma; \mathcal{P} \longrightarrow r \supset s$
						</div>	
					</div>
					<div class="rule-name">
						$\supset_R$
					</div>
				</div>
				<div class="todo">some proof explanation</div>
				<div class="todo">Reference example from book</div>
			</div>

			<div class="hohc examples frame hidden">
				<div class="title">Higher-Order Horn Clauses (HOHC)</div>
				<div class="example">
					<table class="code">
						<tr>
							<td colspan="3">
								/* Signature declarations: */
							</td>
						</tr>
						<tr>
							<td>
								type
							</td>
							<td>
								sublist
							</td>
							<td>
								(A -> o) -> list A -> list A -> o.
							</td>
						</tr>
						<tr>
							<td>
								type
							</td>
							<td>
								flagged
							</td>
							<td>
								A -> o.
							</td>
						</tr>
						<tr>
							<td>
								type
							</td>
							<td>
								u, v, w, x, y, z
							</td>
							<td>
								A.
							</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td colspan="3">
								/* Program definition: */
							</td>
						</tr>
						<tr>
							<td colspan="3">
								sublist P (X :: L) (X :: K) :- P X, sublist P L K.
							</td>
						</tr>
						<tr>
							<td colspan="3">
								sublist P (X :: L) K :- sublist P L K.
							</td>
						</tr>
						<tr>
							<td colspan="3">
								sublist P nil nil.
							</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td colspan="3">
								flagged x, flagged y, flagged z.
							</td>
						</tr>
					</table>
				</div>
				<div class="example">getting the flagged items in a list using sublist predicate as use of higher-order logic</div>
			</div>

			<div class="hohh examples frame last-frame hidden">
				<div class="title">Higher-Order Hereditary Harrop Formulas (HOHH)</div>
				<div class="subtitle">Example: Encoding type inference for a fragment of minimal logic</div>
				<div class="todo">correct understanding of example?</div>
				<div class="example">
					<table class="code">
						<tr>
							<td colspan="3">
								/* Signature declarations: */
							</td>
						</tr>
						<tr>
							<td>kind</td>
							<td>tp</td>
							<td>type.</td>
						</tr>
						<tr>
							<td>type</td>
							<td>basetp</td>
							<td>tp.</td>
						</tr>
						<tr>
							<td>type</td>
							<td>arr</td>
							<td>tp -> tp -> tp.</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td>kind</td>
							<td>expr</td>
							<td>type.</td>	
						</tr>
						<tr>
							<td>type</td>
							<td>app</td>
							<td>expr -> expr -> expr.</td>
						</tr>
						<tr>
							<td>type</td>
							<td>fun</td>
							<td>(expr -> expr) -> expr.</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td>type</td>
							<td>tp_pred</td>
							<td>expr -> tp -> o.</td>
						</tr>
						<tr class="space-row"></tr>
						<tr>
							<td colspan="3">
								/* Program definition: */
							</td>
						</tr>
						<tr>
							<td colspan="3">
								tp_pred (app E1 E2) T1 :- tp_pred E1 (arr T2 T1) & tp_pred E2 T2.
							</td>
						</tr>
						<tr>
							<td colspan="3">
								tp_pred (fun x (E x)) (arr T1 T2) :- pi x \ (tp_pred x T1 => tp_pred (E x) T2).				
							</td>
						</tr>
					</table>
				</div>
				<div class="note">type of <code>fun</code> has order 2, so higher-order</div>
				<div class="note">goal in second <code>tp_pred</code> predicate spec has universal quantification and implication in the goal, so HH</div>
			</div>

			<div class="dock-bottom">
				<button class="collapsible" onclick="expandRules_click()">
					<div class="closed"><span class="em em-arrow_forward"></span></div>
					<div class="open hidden"><span class="em em-arrow_down_small"></span></div>
					<span class="subtitle">Inference Rules</span>
					<span class="em em-hammer_and_wrench"></span>
				</button>
				<div class="scroll hidden">
					<div class="todo">Fix scrolling in rules panel; make minimal example</div>
					<div class="rules">
						<div class="rule_TR rule-container">
							<div class="rule-premises">
							</div>
							<div class="rule-conclusion">
								$ \Sigma ; \mathcal{P} \longrightarrow \top $
							</div>
						</div>
						<div class="rule_or1R rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} \longrightarrow B_1 $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow B_1 \vee B_2 $
								</div>
							</div>
							<div class="rule-name">
								$ \vee_{R_1} $
							</div>
						</div>
						<div class="rule_or2R rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} \longrightarrow B_2 $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow B_1 \vee B_2 $
								</div>
							</div>
							<div>
								$ \vee_{R_2} $
							</div>
						</div>
						<div class="rule_andR rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} \longrightarrow B_1 $</div>
									<div>$ \Sigma ; \mathcal{P} \longrightarrow B_2 $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow B_1 \wedge B_2 $
								</div>
							</div>
							<div>
								$ \wedge_R $
							</div>
						</div>
						<div class="rule_impR rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} , B_1 \longrightarrow B_2 $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow B_1 \supset B_2 $
								</div>
							</div>
							<div>
								$ \supset_R $
							</div>
						</div>
						<div class="rule_forallR rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ c : \tau , \Sigma ; \mathcal{P} \longrightarrow B [c / x] $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow \forall_\tau x \; B $
								</div>
							</div>
							<div>
								$ \forall_R $
							</div>
						</div>
						<div class="rule_existsR rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} \longrightarrow B [t / x] $</div>
									<div>$ \Sigma ; \Gamma \models t : \tau $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \longrightarrow \exists_\tau x \; B $
								</div>
							</div>
							<div>
								$ \exists_R $
							</div>
						</div>
						<div class="rule_backchain rule-container">
							<div class="rule-body">
								<div class="rule-premises">
									<div>$ \Sigma ; \mathcal{P} \longrightarrow A_1 $</div>
									<div>$\ldots$</div>
									<div>$ \Sigma ; \mathcal{P} \longrightarrow A_n $</div>
								</div>
								<div class="rule-conclusion">
									$ \Sigma ; \mathcal{P} \overset{\forall_{\tau_1} x_1 \ldots \forall_{\tau_m} x_m \; (A_1 \wedge \ldots \wedge A_n \supset A_0)}{\longrightarrow} A_0$
								</div>
							</div>
							<div class="rule-name">
								$ backchain $
							</div>
						</div>
					</div>
				</div>
			</div>

		<div class="typing-rules rules hidden">typing rules</div>

		</div>
	</body>
</html>

